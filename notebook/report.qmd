---
title: "MY472 Summative 2 Project"
author: "Candidate 30552"
format: 
    html:
        embed-resources: true 
---


```{r, include = FALSE} 
knitr::opts_chunk$set(
    echo = FALSE, 
    eval = FALSE,
    message = FALSE, 
    warning = FALSE)

```

```{r, eval = TRUE}

# Define function to install or load packages
load_packages <- function(x) {
  y <- x %in% rownames(installed.packages())
  if(any(!y)) install.packages(x[!y])
  invisible(lapply(x, library, character.only=T))
  rm(x, y)
}

# Load required packagess
load_packages(c(
    "tidyverse",
    "here",
    "DBI",
    "RSQLite",
    "httr"
    ))

```


```{r, eval = TRUE}

db_table_check <- function(database, table){
  
  rows <- dbGetQuery(database, paste0("SELECT COUNT(1) FROM ", table))
  cols <- dbListFields(database, table)
  cols_n <- length(cols)
  
  result = list(
    n_rows = rows[[1]],
    n_cols = cols_n,
    col_names = cols)

  return(result)
}

# Define function to print loop progress 

progress_perc <- function(num_done, total, additional_message = ""){
    cat("\r", paste0(additional_message, " ", round(num_done/total*100), "% "))
}

replace_null_with_na <- function(x) {
  if (is.list(x)) { # Checks for whether the item is a sublist 
    lapply(x, replace_null_with_na) # if it is, apply the function for each of the elements within the sublist
  } else { # If it isn't, simply apply the main function
    ifelse(is.null(x) || x == "null", "NA", x) 
  }
}


```


# Introduciton 

# Data 


```{r, eval = TRUE}
db <- DBI::dbConnect(RSQLite::SQLite(), here("data/parliament_database.sqlite"))
```

I draw on 3 sources of data 

1. Data on oral questions 
2. Data on MP characteristics from X
3. Election data from X


Tables: 

1. questions
2. questions_full_text
3. mps
4. ministries 
5. constituencies

The main problem with a relational database is is that characteristics change. So I keep lots in the question table (e.g. current, party etc)

To collect questions from the API, I first request a list of all questions. Contained 

First, I scraped all questions availble from the written and oral endpoints. Both endpoints only return up to 100 questions with one request. However, you can skip responses. Therefore, you can retrieve all questions by looping through... 

These reponses do not return the full text of each question, so I use these responses as a sampling frame 

```{r}

get_qs <- function(endpoint_url, n_skip = 0) {
  url <- paste0(
    endpoint_url,
    "?parameters.skip=",
    n_skip,
    "&parameters.take=100")

  response <-
    GET(url) |>
    content("parsed")

  return(response)
}

# Define functions to pull all questions

pull_all_oral_qs <- function(endpoint_url){

  # Calculate how many questions are in the end point
  n_resp <- GET(paste0(endpoint_url, "?parameters.take=1")) |>
    content("parsed")
  n <- n_resp$PagingInfo$GlobalTotal

  # Questions can be pulled in batches of 100,
  # calculate how many time we will have to pull
  n_loops <- ceiling(n / 100)

  print(paste0("Oral Qs done at ", Sys.time()))

  for (i in 1:n_loops) {

    n_skip <- (i - 1) * 100 # Skip however many 100s the loop has run

    if (i == 1) { # On first iteration, make new list

      response <- get_qs(endpoint_url, n_skip)
      response <- response$Response

    } else { # On all other iterations, append to existing list

      response_new <- get_qs(endpoint_url, n_skip)
      response_new <- response_new$Response
      response <- c(response, response_new) # Merge responses

    }

    print(paste0(i, " of ", n_loops, " done.")) # Print progress message
    Sys.sleep(1) # Sleep to avoid hammering the API

  }

  print(paste0("Oral Qs done at ", Sys.time()))
  return(response)
}

## APPLY FUNCTIONS

oral_questions <- pull_all_oral_qs(
  "https://oralquestionsandmotions-api.parliament.uk/oralquestions/list")

saveRDS(oral_questions, "data/oral_questions.RDS")

```


```{r}
oral_questions <- readRDS("data/oral_questions.RDS")

### Convert elements of the list into tables ###

# Members asking

for (i in seq_along(oral_questions)) {
  if (i == 1) {

    # Extract asking member information
    member_df <- data.frame(lapply(
      oral_questions[[i]]$AskingMember,
      function(x) ifelse(is.null(x), NA, x)))

    member_df$question_id <- oral_questions[[i]]$Id

    oral_questions[[i]]$AskingMember <- NULL 
  } else {

    member_df2 <- data.frame(lapply(
      oral_questions[[i]]$AskingMember,
      function(x) ifelse(is.null(x), NA, x)))

    member_df2$question_id <- oral_questions[[i]]$Id
    member_df <- rbind(member_df, member_df2)

    oral_questions[[i]]$AskingMember <- NULL
  }

 progress_perc(i, length(oral_questions), "MEMBERS:")


}

# Ministers answering

minister_df <- data.frame() # Initialise empty dataframe 

for (i in seq_along(oral_questions)) {
  if (is.null(oral_questions[[i]]$AnsweringMinister) == FALSE){
    
    if (nrow(minister_df) == 0) { # Check whether this is the first to have an answering minister

      minister_df <- data.frame(lapply(
        oral_questions[[i]]$AnsweringMinister,
        function(x) ifelse(is.null(x), NA, x)))

      minister_df$question_id <- oral_questions[[i]]$Id

      oral_questions[[i]]$AnsweringMinister <- NULL # Remove old sublist

    } else {

      minister_df2 <- data.frame(lapply(
        oral_questions[[i]]$AnsweringMinister,
        function(x) ifelse(is.null(x), NA, x)))

      minister_df2$question_id <- oral_questions[[i]]$Id

      minister_df <- rbind(minister_df, minister_df2)

      oral_questions[[i]]$AnsweringMinister <- NULL # Remove old sublist
    }

  } else {
    oral_questions[[i]][["AnsweringMinister"]] <- NULL
  }

 progress_perc(i, length(oral_questions), "MINISTERS:")

}

# Questions

for (i in seq_along(oral_questions)) {
  if (i == 1){
    question_df <- data.frame(lapply(
      oral_questions[[i]],
      function(x) ifelse(is.null(x), NA, x)))
  } else {
    question_df2 <- data.frame(lapply(
      oral_questions[[i]],
      function(x) ifelse(is.null(x), NA, x)))

    question_df <- rbind(question_df, question_df2)
  }

 progress_perc(i, length(oral_questions), "QUESTIONS:")

}

rm(member_df2, minister_df2, question_df2, i)

### Clean dataframes and merge into one table ####

question_df <- question_df %>%
  select(
    question_id = Id,
    question_short_text = QuestionText,
    question_status = Status,
    question_tabled_when = TabledWhen,
    question_answering_when = AnsweringWhen,
    question_answering_body_id = AnsweringBodyId)

minister_df <- minister_df %>%
  select(
    question_id,
    minister_Mnis_ID = MnisId
    )

member_df <- member_df %>%
  select(
    question_id,
    member_asking_Mnis_ID = MnisId)


question_table_main <- 
  left_join(question_df, member_df, by = "question_id")

question_table_main <- 
  left_join(question_table_main, minister_df, by = "question_id")
```

```{r}

dbWriteTable(db, "oral_questions", question_table_main, overwrite = TRUE)
db_table_check(db, "oral_questions")

```


```{r}
questions <- dbGetQuery(db, 
  "
  SELECT *
  FROM oral_questions

  LIMIT 100
  "
  )

glimpse(questions)
```

Many MP characteristics change over time - such as the party they represent, the ministerial posts they hold, etc. Therefore, we have to construct a members table that accomodates these changes. The UK Parliament members API allows queries that specifiy a date.

```{r}
pull_members <- function(base_url, df) {

  cat("\n")
  print(paste0("Started at ", Sys.time()))
  cat("\n")

  pb <- txtProgressBar(min = 0, max = nrow(df), style = 3)
  
  for (i in seq_along(df$member_asking_Mnis_ID)) {

    url <- paste0(base_url, "/", df$member_asking_Mnis_ID[i], "?detailsForDate=", df$question_tabled_when[i]) 

    if (i == 1) {

      response <- GET(url) %>%
        content("parsed")
      response <- response[1]
      response <- c(date = df$question_tabled_when[i], response[[1]])

      response <- list(response)

    } else {
      response_new <- GET(url) %>% content("parsed")
      response_new <- response_new[1]
      response_new <- c(date = df$question_tabled_when[i], response_new[[1]])

      response_new <- list(response_new)

      response <- c(response, response_new) # Merge responses
    }

    Sys.sleep(0.5)

    setTxtProgressBar(pb, i)


  }

  cat("\n")
  print(paste0("Done at ", Sys.time(), " :))"))
  
  return(response)
}

# Connect to database

db <- DBI::dbConnect(RSQLite::SQLite(), here("data/parliament_database.sqlite"))

# Query the question database for the date the question was tables and who asked it 
questions <- dbGetQuery(db, 
  "
  SELECT member_asking_Mnis_ID, question_tabled_when
  FROM oral_questions
  "
)

questions <- unique(questions) # Avoid pulling the same queries by considering unique MP-date combinations

questions <- questions %>%
  mutate(question_tabled_when = str_extract(question_tabled_when, ".+?(?=T)"))

members <- pull_members("https://members-api.parliament.uk/api/Members", questions)

saveRDS(members, "data/members_raw.Rds")

members <-  lapply(members, function(lst) {lapply(lst, replace_null_with_na)})

for (i in seq_along(members)) {

  if (i == 1) {

    members_df <- members[i] %>%
      unlist() %>%
      t() %>%
      data.frame()

  } else {
    members_df_new <- members[i] %>%
      unlist() %>%
      t() %>%
      data.frame()

    members_df <- rbind(members_df, members_df_new)
  }
}

members_df <- members_df %>%
  select(
    member_date_valid = date, 
    member_Mnis_ID = id, 
    member_name_display = nameDisplayAs, 
    member_latest_party = latestParty.id,
    member_gender = gender, 
    member_latest_constituency = latestHouseMembership.membershipFromId,
    member_membership_start_date = latestHouseMembership.membershipStartDate, 
    member_membership_end_date = latestHouseMembership.membershipEndDate,
    member_membership_end_reason = latestHouseMembership.membershipEndReason,
    member_name_full = nameFullTitle,
    member_name_list = nameListAs
  )

members_df <- members_df %>%
  group_by( # Group by all variables apart from date
    member_Mnis_ID,
    member_name_display,
    member_latest_party,
    member_gender,
    member_latest_constituency,
    member_membership_start_date,
    member_membership_end_date,
    member_membership_end_reason,
    member_name_full,
    member_name_list
  ) %>%
  summarize( # Summarise earliest date this is valid for and latest. This gives us a range of vlaues where this combination is duplicated 
    member_date_valid_min = min(member_date_valid), 
    member_date_valid_max = max(member_date_valid)
  )

dbWriteTable(db, "members", members_df, overwrite = TRUE)
```


Finally, we want to collect more information on the characteristics of MPs and their constituencies. 

- MP characteristics
  - On a date `/Members/4498?detailsForDate=2017-11-17` - can be looped by questions 
- Constituency characteristics
  - Previous electoral results 
  - Socio-demographic features of the constituency
- What to add? 
  - Education? from wikipedia? 



Constituency info
- We will get the cosntituency ID from the members pull. We can pull:
  - Election results for each constituency over different elections 
  - Shape files (for plotting later)
- Would like to add 
  - Basic demographic information 
  - Economic indicators 
  - Health indicators 

```{r}

db_table_check(db, "oral_questions")

```



```{r, eval = TRUE}
# Disconnect from local database
DBI::dbDisconnect(db)
```

DIAGRAM OF FINAL RELATIONAL DATABASE

# Analysis 

- Measuring question topic 

- https://www.cambridge.org/core/journals/political-analysis/article/crossdomain-topic-classification-for-political-texts/F074564984969CE168BCBCF5E7D931C8 - could be useful as pre-trained model 

  - Write back out to question table? 




- Measuring important predictos 

# Code appendix
```{r ref.label=knitr::all_labels(), echo=TRUE} 

```